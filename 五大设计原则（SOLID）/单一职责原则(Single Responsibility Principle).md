## ✅ 一、什么是单一职责原则？

> **单一职责原则（SRP）** 是面向对象设计中 **SOLID 五大设计原则** 的第一个。

### 🌟 定义：

> **一个类应该仅有一个引起它变化的原因。**

也就是说：

一个类 **只负责一项职责** ，这项职责发生变化时， **类才可能需要修改** 。

---

## ✅ 二、通俗理解

类、模块、函数都应 **只干一件事** 。

比如：

* 文件操作类只管“读写文件”
* 日志类只管“记录日志”
* 业务逻辑类不要负责“数据持久化”

---

## ✅ 三、违反 SRP 的示例（C++）

```c++
class Report {
public:
    std::string generateReport() {
        return "Report content";
    }

    void saveToFile(const std::string& filename) {
        // ❌ 把报告保存到磁盘
    }

    void printReport() {
        // ❌ 把报告打印出来
    }
};

```

👎 问题：

* `Report` 类既负责 **生成报告** ，又负责 **保存文件** ，还负责 **打印** 。
* 如果打印逻辑变了，或者文件系统换了，都要改这个类，职责不单一。

---

## ✅ 遵守 SRP 的重构版本：

```c++
class Report {
public:
    std::string generate() {
        return "Report content";
    }
};

class ReportSaver {
public:
    void saveToFile(const std::string& content, const std::string& filename) {
        // 单一职责：保存
    }
};

class ReportPrinter {
public:
    void print(const std::string& content) {
        // 单一职责：打印
    }
};

```

👍 优点：

* 每个类都有**唯一职责**
* 改打印逻辑不影响生成和保存
* 代码清晰、易测试、易维护

---

## ✅ 四、SRP 的实际意义

| 优点          | 说明                     |
| ------------- | ------------------------ |
| ✅ 易读性高   | 每个类/函数都很“专注”  |
| ✅ 可维护性强 | 修改影响范围小           |
| ✅ 高复用性   | 单一职责组件更容易重用   |
| ✅ 易于测试   | 单元测试更容易覆盖职责点 |

---

## ✅ 五、适用范围

| 可应用对象 | 说明                           |
| ---------- | ------------------------------ |
| 类         | 类不要又干业务又干 IO          |
| 函数       | 函数不要同时读写又处理         |
| 模块/服务  | 一个服务只做一类事情（微服务） |

---

## ✅ 六、真实场景建议

比如你在开发一个设备同步服务（如你提到的 hover_bridge_daemon），可以按职责拆分：

| 模块              | 职责                               |
| ----------------- | ---------------------------------- |
| `DeviceStatus`  | 只管理设备状态数据结构             |
| `SerialManager` | 只负责串口读写                     |
| `ADBManager`    | 只负责通过 ADB 获取信息            |
| `BridgeService` | 协调所有子模块（可能组合多个职责） |

---

## ✅ 七、一句话总结

> **单一职责原则 = 一个类只做一件事，并且把这一件事做到极致。**
>
