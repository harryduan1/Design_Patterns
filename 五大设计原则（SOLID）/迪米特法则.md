## 一、什么是迪米特法则？

**迪米特法则**又称：

* Law of Demeter（LoD）
* 最少知识原则（Principle of Least Knowledge）

> **定义** ：一个对象应该 **对其他对象有尽可能少的了解** 。
>
> 通俗地说：**“只与你的直接朋友说话，不要和陌生人说话。”**
>


## 二、迪米特法则的基本思想

一个类只应该与以下“朋友”通信：

1. **当前类自身**
2. **方法的参数对象**
3. **方法创建的对象**
4. **成员变量（组合）**
5. **这些对象的接口**

🚫 **不要调用一个对象的对象的方法** （也叫“链式调用”），如：

```c++
auto street = user.getAddress().getStreet(); // ❌ 违反迪米特法则
```

应该改成：

```c++
auto street = user.getStreet(); // ✅ 由 user 提供接口
```



三、示例：违反与遵守对比

🔴 违反迪米特法则

```c++
class Engine {
public:
    void start() { std::cout << "Engine start\n"; }
};

class Car {
private:
    Engine engine;
public:
    Engine& getEngine() { return engine; }  // 暴露内部成员 ❌
};

class Driver {
public:
    void drive(Car& car) {
        car.getEngine().start();  // 间接访问 Engine ❌
    }
};

```

✅ 遵守迪米特法则

```c++
class Car {
private:
    Engine engine;
public:
    void start() {
        engine.start();  // 封装细节 ✅
    }
};

class Driver {
public:
    void drive(Car& car) {
        car.start();  // 只与 Car 交互 ✅
    }
};

```


## 四、优点总结

| 优点                    | 说明             |
| ----------------------- | ---------------- |
| ✅ 降低耦合             | 类之间的依赖更少 |
| ✅ 增强封装             | 内部结构对外隐藏 |
| ✅ 提高复用性和可维护性 | 改动影响范围更小 |



## 五、实际开发中常见违反场景

| 场景               | 示例                                    |
| ------------------ | --------------------------------------- |
| 链式调用           | `a->getB()->getC()->doSomething();`❌ |
| 暴露内部成员对象   | 提供 getter 返回指针或引用 ❌           |
| 把细节交给外部处理 | 外部根据内部对象再去做逻辑 ❌           |

---

## 六、什么时候可以适当违反？

虽然迪米特法则很好，但 **并不是绝对不能违反** 。例如：

* 流式 API（如 `builder.setA().setB().build()`）在链式调用中是合理的
* 性能敏感场景中减少中转层可能更高效

遵守原则时要平衡  **封装性、可读性、性能与开发成本** 。

---

## 七、总结一句话

> **迪米特法则**是一种**降低类之间耦合度**的设计指导原则，
>
> 鼓励对象只与“亲密朋友”交流，隐藏内部结构，避免不必要的依赖。
>
