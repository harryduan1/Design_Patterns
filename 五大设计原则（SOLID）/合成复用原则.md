## ✅ 一、定义

> **合成复用原则（Composite Reuse Principle）** 指的是：
>
> **尽量使用“对象组合”来实现代码复用，而不是使用“类继承”。**

通俗讲就是：

> 与其“继承一个类来获得其功能”，不如“在类中组合另一个类，并通过委托来使用其功能”。

---

## ✅ 二、举例说明

### 👎 违反合成复用原则（使用继承）：

```c++
class Animal {
public:
    void breathe() { std::cout << "Breathing...\n"; }
};

class Dog : public Animal {
public:
    void bark() { std::cout << "Barking...\n"; }
};

```

虽然 `Dog` 能复用 `Animal` 的 `breathe()` 方法，但它**强耦合**于 `Animal`， **一旦 Animal 变动，Dog 也会受到影响** 。

---

### ✅ 遵守合成复用原则（使用组合）：

```c++
class BreathingModule {
public:
    void breathe() { std::cout << "Breathing...\n"; }
};

class Dog {
private:
    BreathingModule breathing;
public:
    void bark() { std::cout << "Barking...\n"; }
    void breathe() { breathing.breathe(); } // 组合复用
};

```

这里，`Dog` 通过组合 `BreathingModule` 来复用功能，二者是**松耦合**的， **扩展性和灵活性更高** 。

---

## ✅ 三、合成 vs 继承 比较

| 对比点   | 继承（Inheritance）        | 合成（Composition）          |
| -------- | -------------------------- | ---------------------------- |
| 关系类型 | is-a（是一种）             | has-a（拥有一个）            |
| 耦合度   | 高耦合（父类变化影响子类） | 松耦合（内部变化不影响外部） |
| 复用方式 | 编译时复用（静态）         | 运行时复用（动态）           |
| 灵活性   | 不灵活（继承树固定）       | 更灵活（可组合不同模块）     |
| 可测试性 | 一般                       | 更好（组合可 mock）          |
| 扩展性   | 差，容易破坏封装           | 好，可自由组合功能模块       |

---

## ✅ 四、合成复用原则的优势

1. ✅  **降低耦合** ：改变组合类不会影响使用它的类。
2. ✅  **增强灵活性** ：可以在运行时动态组合不同行为。
3. ✅  **符合开闭原则** ：新增功能可通过组合扩展，而非修改已有类。
4. ✅  **提升模块复用性** ：多个对象可以复用同一个组合类。

---

## ✅ 五、相关设计模式体现此原则：

| 模式名称             | 如何体现合成复用                     |
| -------------------- | ------------------------------------ |
| **策略模式**   | 把算法封装成独立类，通过组合切换策略 |
| **装饰器模式** | 通过组合添加行为，而不是继承修改原类 |
| **桥接模式**   | 抽象与实现通过组合桥接               |
| **适配器模式** | 将已有类组合进新结构中以兼容新接口   |

---

## ✅ 六、总结一句话：

> **合成复用原则强调“组合优于继承”，鼓励通过对象组合和委托来实现复用，避免深层继承带来的脆弱性和耦合问题。**
>
